<documents created="2013-03-05 19:43:04Z"><document src="F:\Ajay\Test Projects\GameOfLife\GameOfLife.Library\Specifications\IsOverCrowdedSpecification.cs" renderPrefix="s0"><chunk hits="-1" domain="unknown"><source><![CDATA[using System.Linq;
using DataAccess.Specification;
using GameOfLife.Contracts;
namespace GameOfLife.Core.Specifications
{
    /// <summary>
    /// Check whether the specific cell is overcrowded or not
    /// Rule for overcrowded is : cell is alive and no of neigbours > 3
    /// </summary>
    public class IsOverCrowdedSpecification  :ISpecification<ICellInfo>
    {
        private readonly IGrid _grid;
        private readonly INeighbour _neighbour;
        ]]></source>
</chunk>
<method name=".ctor" namespace="GameOfLife.Core.Specifications" type="GameOfLife.Core.Specifications.IsOverCrowdedSpecification" typeName="IsOverCrowdedSpecification" token="600001e" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="2" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
<hit index="7" value="1"/>
<hit index="8" value="1"/>
<hit index="9" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="3" total="3" coveredRatio="1"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[public IsOverCrowdedSpecification(IGrid grid)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0007" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0008" domain="usercodeundertest"><source><![CDATA[_grid = grid;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            //This dependency can also be injected with any DI containers for e.g Unity, Autofac or Ninject
            ]]></source>
</chunk>
<chunk hits="2" offset="000f" domain="usercodeundertest"><source><![CDATA[_neighbour=new NeighboursFinder();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="2" offset="001a" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        /// <summary>
        /// Apply business logic
        /// </summary>
        /// <param name="currentCell">Cell for which logic needs to apply</param>
        /// <returns>True if o</returns>
        public bool IsSatisfiedBy(ICellInfo currentCell)
        ]]></source>
</chunk>
<method name="IsSatisfiedBy" namespace="GameOfLife.Core.Specifications" type="GameOfLife.Core.Specifications.IsOverCrowdedSpecification" typeName="IsOverCrowdedSpecification" token="600001f" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="2" total="13" coveredRatio="0.15384615384615386"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[if (currentCell == null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="1" offset="000c" domain="usercodeundertest"><source><![CDATA[return false;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            //Reterive total neighbours
            ]]></source>
</chunk>
<chunk hits="0" offset="0010" domain="usercodeundertest"><source><![CDATA[var neighbours = _neighbour.RetrieveNeighbours(currentCell, _grid);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0023" domain="usercodeundertest"><source><![CDATA[var aliveNeighbours = neighbours.Where(n => n.Alive).ToList();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="004e" domain="usercodeundertest"><source><![CDATA[return (currentCell.Alive && aliveNeighbours.Count > 3);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0065" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
    }
}
]]></source>
</chunk>
</document>
<document src="F:\Ajay\Test Projects\GameOfLife\GameOfLife.Library\GameRules.cs" renderPrefix="s1"><chunk hits="-1" domain="unknown"><source><![CDATA[using System;
using GameOfLife.Contracts;
using GameOfLife.Core.Specifications;

namespace GameOfLife.Core
{
    /// <summary>
    /// 
    /// </summary>
    public class GameRules : IGameRules
    {

        public bool WillBeAliveInNextGeneration(IGrid grid, ICellInfo cell)
        ]]></source>
</chunk>
<method name="WillBeAliveInNextGeneration" namespace="GameOfLife.Core" type="GameOfLife.Core.GameRules" typeName="GameRules" token="6000018" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="2" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
<hit index="23" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="3" total="16" coveredRatio="0.1875"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[if (cell == null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="1" offset="000c" domain="usercodeundertest"><source><![CDATA[throw new ArgumentNullException("cell");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0017" domain="usercodeundertest"><source><![CDATA[if (IsOverCrowded(grid,cell))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0026" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                //Any live cell with more than three live neighbours dies, as if by overcrowding.
                ]]></source>
</chunk>
<chunk hits="0" offset="0027" domain="usercodeundertest"><source><![CDATA[return false;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }                          
            ]]></source>
</chunk>
<chunk hits="0" offset="002b" domain="usercodeundertest"><source><![CDATA[if (IsSurvivable(grid,cell))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="003a" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                //Any live cell with two or three live neighbours lives on to the next generation.
                ]]></source>
</chunk>
<chunk hits="0" offset="003b" domain="usercodeundertest"><source><![CDATA[return true;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
            ]]></source>
</chunk>
<chunk hits="0" offset="003f" domain="usercodeundertest"><source><![CDATA[if (IsUnderPopulated(grid, cell))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="004e" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                //Any live cell with fewer than two live neighbours dies, as if caused by under-population.
                ]]></source>
</chunk>
<chunk hits="0" offset="004f" domain="usercodeundertest"><source><![CDATA[return false;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
            ]]></source>
</chunk>
<chunk hits="0" offset="0053" domain="usercodeundertest"><source><![CDATA[if (IsReproduciable(grid, cell))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0062" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                //Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction
                ]]></source>
</chunk>
<chunk hits="0" offset="0063" domain="usercodeundertest"><source><![CDATA[return true;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
            ]]></source>
</chunk>
<chunk hits="0" offset="0067" domain="usercodeundertest"><source><![CDATA[return false;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="006b" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        public bool IsReproduciable(IGrid grid,ICellInfo cell)
        ]]></source>
</chunk>
<method name="IsReproduciable" namespace="GameOfLife.Core" type="GameOfLife.Core.GameRules" typeName="GameRules" token="6000019" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="3" total="3" coveredRatio="1"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[return new IsReproduciableSpecification(grid).IsSatisfiedBy(cell);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0010" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        public bool IsUnderPopulated(IGrid grid, ICellInfo cell)
        ]]></source>
</chunk>
<method name="IsUnderPopulated" namespace="GameOfLife.Core" type="GameOfLife.Core.GameRules" typeName="GameRules" token="600001a" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="3" total="3" coveredRatio="1"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[return new IsUnderPopulatedSpecification(grid).IsSatisfiedBy(cell);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0010" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        public bool IsSurvivable(IGrid grid, ICellInfo cell)
        ]]></source>
</chunk>
<method name="IsSurvivable" namespace="GameOfLife.Core" type="GameOfLife.Core.GameRules" typeName="GameRules" token="600001b" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="3" total="3" coveredRatio="1"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[return new IsSurvivableSpecification(grid).IsSatisfiedBy(cell);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0010" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        public bool IsOverCrowded(IGrid grid, ICellInfo cell)
        ]]></source>
</chunk>
<method name="IsOverCrowded" namespace="GameOfLife.Core" type="GameOfLife.Core.GameRules" typeName="GameRules" token="600001c" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="3" total="3" coveredRatio="1"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[return new IsOverCrowdedSpecification(grid).IsSatisfiedBy(cell);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0010" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

    }
}]]></source>
</chunk>
</document>
<document src="F:\Ajay\Test Projects\GameOfLife\GameOfLife.Library\Specifications\IsReproduciableSpecification.cs" renderPrefix="s2"><chunk hits="-1" domain="unknown"><source><![CDATA[using System.Linq;
using DataAccess.Specification;
using GameOfLife.Contracts;
namespace GameOfLife.Core.Specifications
{
    /// <summary>
    /// Check whether the specific cell is overcrowded or not
    /// Rule for overcrowded is : cell is alive and no of neigbours > 3
    /// </summary>
    public class IsReproduciableSpecification  :ISpecification<ICellInfo>
    {
        private readonly IGrid _grid;
        private readonly INeighbour _neighbour;
        ]]></source>
</chunk>
<method name=".ctor" namespace="GameOfLife.Core.Specifications" type="GameOfLife.Core.Specifications.IsReproduciableSpecification" typeName="IsReproduciableSpecification" token="6000006" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="2" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
<hit index="7" value="1"/>
<hit index="8" value="1"/>
<hit index="9" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="3" total="3" coveredRatio="1"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[public IsReproduciableSpecification(IGrid grid)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0007" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0008" domain="usercodeundertest"><source><![CDATA[_grid = grid;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            //This dependency can also be injected with any DI containers for e.g Unity, Autofac or Ninject
            ]]></source>
</chunk>
<chunk hits="2" offset="000f" domain="usercodeundertest"><source><![CDATA[_neighbour=new NeighboursFinder();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="2" offset="001a" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        /// <summary>
        /// Apply business logic
        /// </summary>
        /// <param name="currentCell">Cell for which logic needs to apply</param>
        /// <returns>True if o</returns>
        public bool IsSatisfiedBy(ICellInfo currentCell)
        ]]></source>
</chunk>
<method name="IsSatisfiedBy" namespace="GameOfLife.Core.Specifications" type="GameOfLife.Core.Specifications.IsReproduciableSpecification" typeName="IsReproduciableSpecification" token="6000007" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="2" total="13" coveredRatio="0.15384615384615386"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[if (currentCell == null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="1" offset="000c" domain="usercodeundertest"><source><![CDATA[return false;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            //Reterive total neighbours
            ]]></source>
</chunk>
<chunk hits="0" offset="0010" domain="usercodeundertest"><source><![CDATA[var neighbours = _neighbour.RetrieveNeighbours(currentCell, _grid);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0023" domain="usercodeundertest"><source><![CDATA[var aliveNeighbours = neighbours.Where(n => n.Alive).ToList();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="004e" domain="usercodeundertest"><source><![CDATA[return (currentCell.Alive==false && aliveNeighbours.Count ==3);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0065" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
    }
}
]]></source>
</chunk>
</document>
<document src="F:\Ajay\Test Projects\GameOfLife\GameOfLife.Library\Specifications\IsSurvivableSpecification.cs" renderPrefix="s3"><chunk hits="-1" domain="unknown"><source><![CDATA[using System.Linq;
using DataAccess.Specification;
using GameOfLife.Contracts;
namespace GameOfLife.Core.Specifications
{
    /// <summary>
    /// Check whether the specific cell is overcrowded or not
    /// Rule for overcrowded is : cell is alive and no of neigbours > 3
    /// </summary>
    public class IsSurvivableSpecification  :ISpecification<ICellInfo>
    {
        private readonly IGrid _grid;
        private readonly INeighbour _neighbour;
        ]]></source>
</chunk>
<method name=".ctor" namespace="GameOfLife.Core.Specifications" type="GameOfLife.Core.Specifications.IsSurvivableSpecification" typeName="IsSurvivableSpecification" token="6000003" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="2" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
<hit index="7" value="1"/>
<hit index="8" value="1"/>
<hit index="9" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="3" total="3" coveredRatio="1"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[public IsSurvivableSpecification(IGrid grid)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0007" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0008" domain="usercodeundertest"><source><![CDATA[_grid = grid;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            //This dependency can also be injected with any DI containers for e.g Unity, Autofac or Ninject
            ]]></source>
</chunk>
<chunk hits="2" offset="000f" domain="usercodeundertest"><source><![CDATA[_neighbour=new NeighboursFinder();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="2" offset="001a" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        /// <summary>
        /// Apply business logic
        /// </summary>
        /// <param name="currentCell">Cell for which logic needs to apply</param>
        /// <returns>True if o</returns>
        public bool IsSatisfiedBy(ICellInfo currentCell)
        ]]></source>
</chunk>
<method name="IsSatisfiedBy" namespace="GameOfLife.Core.Specifications" type="GameOfLife.Core.Specifications.IsSurvivableSpecification" typeName="IsSurvivableSpecification" token="6000004" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="2" total="16" coveredRatio="0.125"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[if (currentCell == null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="1" offset="000c" domain="usercodeundertest"><source><![CDATA[return false;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            //Reterive total neighbours
            ]]></source>
</chunk>
<chunk hits="0" offset="0010" domain="usercodeundertest"><source><![CDATA[var neighbours = _neighbour.RetrieveNeighbours(currentCell, _grid);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0023" domain="usercodeundertest"><source><![CDATA[var aliveNeighbours = neighbours.Where(n => n.Alive).ToList();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="004e" domain="usercodeundertest"><source><![CDATA[return (currentCell.Alive && (aliveNeighbours.Count == 2 || aliveNeighbours.Count==3));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0071" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
    }
}
]]></source>
</chunk>
</document>
<document src="F:\Ajay\Test Projects\GameOfLife\GameOfLife.Library\Specifications\IsUnderPopulatedSpecification.cs" renderPrefix="s4"><chunk hits="-1" domain="unknown"><source><![CDATA[using System.Linq;
using DataAccess.Specification;
using GameOfLife.Contracts;
namespace GameOfLife.Core.Specifications
{
    /// <summary>
    /// Check whether the specific cell is overcrowded or not
    /// Rule for overcrowded is : cell is alive and no of neigbours > 3
    /// </summary>
    public class IsUnderPopulatedSpecification  :ISpecification<ICellInfo>
    {
        private readonly IGrid _grid;
        private readonly INeighbour _neighbour;
        ]]></source>
</chunk>
<method name=".ctor" namespace="GameOfLife.Core.Specifications" type="GameOfLife.Core.Specifications.IsUnderPopulatedSpecification" typeName="IsUnderPopulatedSpecification" token="6000009" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="2" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
<hit index="7" value="1"/>
<hit index="8" value="1"/>
<hit index="9" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="3" total="3" coveredRatio="1"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[public IsUnderPopulatedSpecification(IGrid grid)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0007" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0008" domain="usercodeundertest"><source><![CDATA[_grid = grid;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            //This dependency can also be injected with any DI containers for e.g Unity, Autofac or Ninject
            ]]></source>
</chunk>
<chunk hits="2" offset="000f" domain="usercodeundertest"><source><![CDATA[_neighbour=new NeighboursFinder();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="2" offset="001a" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        /// <summary>
        /// Apply business logic
        /// </summary>
        /// <param name="currentCell">Cell for which logic needs to apply</param>
        /// <returns>True if o</returns>
        public bool IsSatisfiedBy(ICellInfo currentCell)
        ]]></source>
</chunk>
<method name="IsSatisfiedBy" namespace="GameOfLife.Core.Specifications" type="GameOfLife.Core.Specifications.IsUnderPopulatedSpecification" typeName="IsUnderPopulatedSpecification" token="600000a" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="2" total="13" coveredRatio="0.15384615384615386"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[if (currentCell == null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="1" offset="000c" domain="usercodeundertest"><source><![CDATA[return false;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            //Reterive total neighbours
            ]]></source>
</chunk>
<chunk hits="0" offset="0010" domain="usercodeundertest"><source><![CDATA[var neighbours = _neighbour.RetrieveNeighbours(currentCell, _grid);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0023" domain="usercodeundertest"><source><![CDATA[var aliveNeighbours = neighbours.Where(n => n.Alive).ToList();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="004e" domain="usercodeundertest"><source><![CDATA[return (currentCell.Alive && aliveNeighbours.Count < 2);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0065" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
    }
}
]]></source>
</chunk>
</document>
<document src="F:\Ajay\Test Projects\GameOfLife\GameOfLife.Library\Generation.cs" renderPrefix="s5"><chunk hits="-1" domain="unknown"><source><![CDATA[using GameOfLife.Contracts;

namespace GameOfLife.Core
{
    /// <summary>
    /// Implement Game of life generation (simualtion) algorithms                                                                                      
    /// </summary>
    public class Generation : IGeneration
    {
        /// <summary>
        /// By applying game rules get the next genertion grid instance
        /// </summary>
        /// <param name="currentGrid">Grid on which games rules</param>
        /// <param name="gameRules"> </param>
        /// <returns>Evolved grid instance</returns>
        public IGrid GetNextGeneration(IGrid currentGrid,IGameRules gameRules)
        ]]></source>
</chunk>
<method name="GetNextGeneration" namespace="GameOfLife.Core" type="GameOfLife.Core.Generation" typeName="Generation" token="6000001" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="48" value="1"/>
<hit index="49" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="3" total="18" coveredRatio="0.16666666666666666"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[if (currentGrid!=null && gameRules!=null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="000f" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0010" domain="usercodeundertest"><source><![CDATA[var gridCopy = currentGrid.Copy(currentGrid);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0018" domain="usercodeundertest"><source><![CDATA[foreach]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ (]]></source>
</chunk>
<chunk hits="0" offset="0028" domain="usercodeundertest"><source><![CDATA[var cell]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="0049" domain="usercodeundertest"><source><![CDATA[in]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="0019" domain="usercodeundertest"><source><![CDATA[currentGrid.GetAllCurrentCellInfo()]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[)
                ]]></source>
</chunk>
<chunk hits="0" offset="0030" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    ]]></source>
</chunk>
<chunk hits="0" offset="0031" domain="usercodeundertest"><source><![CDATA[cell.Alive = gameRules.WillBeAliveInNextGeneration(gridCopy, cell);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    ]]></source>
</chunk>
<chunk hits="0" offset="0040" domain="usercodeundertest"><source><![CDATA[gridCopy.MakeCell(cell);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0048" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0069" domain="usercodeundertest"><source><![CDATA[return gridCopy;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
            ]]></source>
</chunk>
<chunk hits="1" offset="006d" domain="usercodeundertest"><source><![CDATA[return null;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0071" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
    }
}
]]></source>
</chunk>
</document>
<document src="F:\Ajay\Test Projects\GameOfLife\GameOfLife.Library\Grid.cs" renderPrefix="s6"><chunk hits="-1" domain="unknown"><source><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using GameOfLife.Contracts;
using GameOfLife.Data;
using GameOfLife.Models;


namespace GameOfLife.Core
{
    /// <summary>
    ///  the grid is a "board" with an extra row on top & bottom and an extra column left & right (with dead cells)
    ///  takes care of the position transformations
    /// </summary>
    public class Grid : IGrid
    {
        private readonly IGridStorage _gridStorage;

        ]]></source>
</chunk>
<method name=".ctor" namespace="GameOfLife.Core" type="GameOfLife.Core.Grid" typeName="Grid" token="600000c" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="2" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="6" value="1"/>
<hit index="7" value="1"/>
<hit index="17" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="4" total="7" coveredRatio="0.5714285714285714"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[public Grid(IGridSize gridSize)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0007" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0008" domain="usercodeundertest"><source><![CDATA[if (gridSize == null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="1" offset="0013" domain="usercodeundertest"><source><![CDATA[throw new ArgumentNullException("gridSize");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="001e" domain="usercodeundertest"><source><![CDATA[GridSize = gridSize;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0026" domain="usercodeundertest"><source><![CDATA[_gridStorage = new GridStorage(gridSize);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="0032" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[


        public ICellInfo GetCurrentCellInfo(IPosition position)
        {
            if (position == null) throw new ArgumentNullException("position");
            if (!IsValidPosition(position)) throw new ArgumentOutOfRangeException("position");
            var gridPosition = CreateGridPositionFrom(position);
            var isCellAlive = _gridStorage.IsCellAlive(gridPosition);
            var newCell = new CellInfo(position, isCellAlive);
            return newCell;
        }

        public IEnumerable<ICellInfo> GetAllCurrentCellInfo()
        {
            for (int i = 0; i < GridSize.Rows; i++)
            {
                for (int j = 0; j < GridSize.Columns; j++)
                {
                    yield return GetCurrentCellInfo(new Position(i, j));
                }
            }
        }

        //public IEnumerable<ICellInfo> GetAllNextGenerationCellInfo()
        //{
        //    for (int i = 0; i < GridSize.Rows; i++)
        //    {
        //        for (int j = 0; j < GridSize.Columns; j++)
        //        {
        //            yield return CreateNextGenerationCellInfo(new Position(i, j));
        //        }
        //    }
        //}

        public void MakeCell(IPosition position, bool alive)
        {
            if (position == null) throw new ArgumentNullException("position");
            if (!IsValidPosition(position)) throw new ArgumentOutOfRangeException("position");
            var gridPosition = CreateGridPositionFrom(position);
            _gridStorage.SetCell(gridPosition, alive);
        }
        public void MakeCell(ICellInfo cell)
        {
            MakeCell(cell.Position, cell.Alive);
        }

        /// <summary>
        /// Create new instance of current grid
        /// </summary>
        /// <param name="currentGrid">Current grid</param>
        /// <returns>Retunr new grid instance</returns>
        public IGrid Copy(IGrid currentGrid)
        {
            var gridCopy = new Grid(currentGrid.GridSize);
            foreach (var newCell in currentGrid.GetAllCurrentCellInfo().Select(cell => new CellInfo(cell.Position, cell.Alive)))
            {
                gridCopy.MakeCell(newCell);
            }

            return gridCopy;
        }

        //private static IGridSize CreateGridSizeFrom(IBoardSize boardSize)
        //{
        //    return new GridSize(boardSize.Rows, boardSize.Columns);
        //}

        //private static IGridSize CreateGridSizeFrom(IGridSize gridSize)
        //{
        //    return new GridSize(gridSize.Rows, gridSize.Columns);
        //}


        #region Private Members

        //private ICellInfo CreateNextGenerationCellInfo(IPosition position)
        //{
        //    var gridPosition = CreateGridPositionFrom(position);
        //    var currentExtendedGridCellInfo = _gridStorage.CreateExtendedGridCellInfo(gridPosition);
        //    var aliveNextGeneration = _gameRules.WillBeAliveNextGeneration(currentExtendedGridCellInfo);
        //    return new CellInfo(position, aliveNextGeneration);
        //}

        private IGridPosition CreateGridPositionFrom(IPosition position)
        {
            return new GridPosition(position);
        }

        private bool IsValidPosition(IPosition position)
        {
            return (position.Column < GridSize.Columns && position.Row < GridSize.Rows);
        }

        //private void MakeCell(ICellInfo cellInfo)
        //{
        //    MakeCell(cellInfo.Position, cellInfo.Alive);
        //}

        #endregion


        public void Initialize(IEnumerable<ICellInfo> cells)
        {
            if (cells == null) return;
            foreach (var cell in cells)
            {
                MakeCell(cell.Position, cell.Alive);
            }
        }

        public IGridSize GridSize { get; set; }

        //public IGrid CreateNextGeneration()
        //{
        //    throw new NotImplementedException();
        //}


    }
}]]></source>
</chunk>
</document>
<document src="F:\Ajay\Test Projects\GameOfLife\GameOfLife.Library\NeighboursFinder.cs" renderPrefix="s7"><chunk hits="-1" domain="unknown"><source><![CDATA[using System.Collections.Generic;
using GameOfLife.Contracts;

namespace GameOfLife.Core
{
    /// <summary>
    /// Find total alive neighbours of a specific cell
    /// </summary>
    public class NeighboursFinder : INeighbour
    {
        /// <summary>
        /// Count how many neighbours of the specific cell are alive.
        /// There are total 8 neighbours for a specific cell
        /// </summary>
        /// <param name="cell">Cell for which neighbours needs to be find</param>
        /// <param name="grid">Grid which contains all cell information</param>
        /// <returns>Retruns the info of all neighbours</returns>
        public IEnumerable<ICellInfo> RetrieveNeighbours(ICellInfo cell, IGrid grid)
        ]]></source>
</chunk>
<method name="RetrieveNeighbours" namespace="GameOfLife.Core" type="GameOfLife.Core.NeighboursFinder" typeName="NeighboursFinder" token="6000021" module="GameOfLife.Core.dll"><hits><hit index="0" value="1"/>
<hit index="2" value="1"/>
<hit index="290" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="3" total="95" coveredRatio="0.031578947368421054"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[if (cell == null || grid == null)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="1" offset="0012" domain="usercodeundertest"><source><![CDATA[return null;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0019" domain="usercodeundertest"><source><![CDATA[var neighbours = new List<ICellInfo>();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="001f" domain="usercodeundertest"><source><![CDATA[var currCellPosition = cell.Position;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            //CalculateDiagonalTopLeftNeighbour
            ]]></source>
</chunk>
<chunk hits="0" offset="0026" domain="usercodeundertest"><source><![CDATA[currCellPosition.Row = cell.Position.Row - 1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="003a" domain="usercodeundertest"><source><![CDATA[currCellPosition.Column = cell.Position.Column - 1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="004e" domain="usercodeundertest"><source><![CDATA[if(IsValidIndex(currCellPosition,grid))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="005d" domain="usercodeundertest"><source><![CDATA[neighbours.Add(grid.GetCurrentCellInfo(currCellPosition));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            //CalculateTopNeighbour
            ]]></source>
</chunk>
<chunk hits="0" offset="006b" domain="usercodeundertest"><source><![CDATA[currCellPosition.Row = cell.Position.Row - 1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="007f" domain="usercodeundertest"><source><![CDATA[currCellPosition.Column = cell.Position.Column;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0091" domain="usercodeundertest"><source><![CDATA[if (IsValidIndex(currCellPosition, grid))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="00a0" domain="usercodeundertest"><source><![CDATA[neighbours.Add(grid.GetCurrentCellInfo(currCellPosition));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            //CalculateDiagonalTopRightNeighbour
            ]]></source>
</chunk>
<chunk hits="0" offset="00ae" domain="usercodeundertest"><source><![CDATA[currCellPosition.Row = cell.Position.Row - 1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="00c2" domain="usercodeundertest"><source><![CDATA[currCellPosition.Column = cell.Position.Column + 1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="00d6" domain="usercodeundertest"><source><![CDATA[if (IsValidIndex(currCellPosition, grid))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="00e5" domain="usercodeundertest"><source><![CDATA[neighbours.Add(grid.GetCurrentCellInfo(currCellPosition));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            //CalculateLeftNeighbour
            ]]></source>
</chunk>
<chunk hits="0" offset="00f3" domain="usercodeundertest"><source><![CDATA[currCellPosition.Row = cell.Position.Row;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0105" domain="usercodeundertest"><source><![CDATA[currCellPosition.Column = cell.Position.Column - 1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0119" domain="usercodeundertest"><source><![CDATA[if (IsValidIndex(currCellPosition, grid))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="0128" domain="usercodeundertest"><source><![CDATA[neighbours.Add(grid.GetCurrentCellInfo(currCellPosition));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            //CalculateRightNeighbour
            ]]></source>
</chunk>
<chunk hits="0" offset="0136" domain="usercodeundertest"><source><![CDATA[currCellPosition.Row = cell.Position.Row;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0148" domain="usercodeundertest"><source><![CDATA[currCellPosition.Column = cell.Position.Column + 1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="015c" domain="usercodeundertest"><source><![CDATA[if (IsValidIndex(currCellPosition, grid))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="016b" domain="usercodeundertest"><source><![CDATA[neighbours.Add(grid.GetCurrentCellInfo(currCellPosition));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            //CalculateDiagonalBottomLeftNeighbour
            ]]></source>
</chunk>
<chunk hits="0" offset="0179" domain="usercodeundertest"><source><![CDATA[currCellPosition.Row = cell.Position.Row + 1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="018d" domain="usercodeundertest"><source><![CDATA[currCellPosition.Column = cell.Position.Column - 1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="01a1" domain="usercodeundertest"><source><![CDATA[if (IsValidIndex(currCellPosition, grid))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="01b0" domain="usercodeundertest"><source><![CDATA[neighbours.Add(grid.GetCurrentCellInfo(currCellPosition));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
 
            //CalculateBottomNeighbour
            ]]></source>
</chunk>
<chunk hits="0" offset="01be" domain="usercodeundertest"><source><![CDATA[currCellPosition.Row = cell.Position.Row + 1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="01d2" domain="usercodeundertest"><source><![CDATA[currCellPosition.Column = cell.Position.Column;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="01e4" domain="usercodeundertest"><source><![CDATA[if (IsValidIndex(currCellPosition, grid))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="01f3" domain="usercodeundertest"><source><![CDATA[neighbours.Add(grid.GetCurrentCellInfo(currCellPosition));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            //CalculateDiagonalBottomRightNeighbour
            ]]></source>
</chunk>
<chunk hits="0" offset="0201" domain="usercodeundertest"><source><![CDATA[currCellPosition.Row = cell.Position.Row + 1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0215" domain="usercodeundertest"><source><![CDATA[currCellPosition.Column = cell.Position.Column + 1;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0229" domain="usercodeundertest"><source><![CDATA[if (IsValidIndex(currCellPosition, grid))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="0238" domain="usercodeundertest"><source><![CDATA[neighbours.Add(grid.GetCurrentCellInfo(currCellPosition));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            ]]></source>
</chunk>
<chunk hits="0" offset="0246" domain="usercodeundertest"><source><![CDATA[return neighbours;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="024a" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        /// <summary>
        /// Check whether the current requested cell position is valid withing grid or not
        /// </summary>
        /// <param name="position">Position information</param>
        /// <param name="grid">Grid instance to check</param>
        /// <returns>If valid return true else false</returns>
        private bool IsValidIndex(IPosition position,IGrid grid)
        {
            if (position.Row > grid.GridSize.Rows - 1 || position.Row < 0) return false;

            if (position.Column > grid.GridSize.Columns - 1 || position.Column < 0) return false;

            return true;
        }
    }
}
]]></source>
</chunk>
</document>
<document src="(no sources available for some parts of GameOfLife.Core, GameOfLife.Core.Tests, GameOfLife.Core.Explorables)" missing="true"><method name=".ctor" type="GameOfLife.Core.NeighboursFinder" token="6000023" module="GameOfLife.Core.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="IsOverCrowded" type="GameOfLife.Core.GameRulesTest" token="6000014" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="IsReproduciable" type="GameOfLife.Core.GameRulesTest" token="6000015" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="IsSurvivable" type="GameOfLife.Core.GameRulesTest" token="6000016" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="IsUnderPopulated" type="GameOfLife.Core.GameRulesTest" token="6000017" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="WillBeAliveInNextGeneration" type="GameOfLife.Core.GameRulesTest" token="6000018" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="GetNextGeneration" type="GameOfLife.Core.GenerationTest" token="6000001" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="Constructor" type="GameOfLife.Core.GridTest" token="600000c" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="1" total="2" coveredRatio="0.5"/>
</method>
<method name="RetrieveNeighbours" type="GameOfLife.Core.NeighboursFinderTest" token="600001d" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="Constructor" type="GameOfLife.Core.Specifications.IsOverCrowdedSpecificationTest" token="600001a" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="Create" type="GameOfLife.Core.Specifications.IsOverCrowdedSpecificationFactory" token="6000004" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="IsSatisfiedBy" type="GameOfLife.Core.Specifications.IsOverCrowdedSpecificationTest" token="600001b" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="Constructor" type="GameOfLife.Core.Specifications.IsReproduciableSpecificationTest" token="6000006" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="Create" type="GameOfLife.Core.Specifications.IsReproduciableSpecificationFactory" token="6000006" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="IsSatisfiedBy" type="GameOfLife.Core.Specifications.IsReproduciableSpecificationTest" token="6000007" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="Constructor" type="GameOfLife.Core.Specifications.IsSurvivableSpecificationTest" token="6000003" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="Create" type="GameOfLife.Core.Specifications.IsSurvivableSpecificationFactory" token="6000008" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="IsSatisfiedBy" type="GameOfLife.Core.Specifications.IsSurvivableSpecificationTest" token="6000004" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="Constructor" type="GameOfLife.Core.Specifications.IsUnderPopulatedSpecificationTest" token="6000009" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
<method name="Create" type="GameOfLife.Core.Specifications.IsUnderPopulatedSpecificationFactory" token="600000a" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="IsSatisfiedBy" type="GameOfLife.Core.Specifications.IsUnderPopulatedSpecificationTest" token="600000a" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="2" total="2" coveredRatio="1"/>
</method>
</document>
</documents>
